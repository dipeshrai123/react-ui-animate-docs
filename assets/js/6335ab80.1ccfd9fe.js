"use strict";(self.webpackChunkreact_ui_animate_docs=self.webpackChunkreact_ui_animate_docs||[]).push([[847],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=r,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(f,i(i({ref:t},c),{},{components:n})):a.createElement(f,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},512:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return p}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={sidebar_position:5,id:"gestures",title:"Gestures"},l=void 0,u={unversionedId:"gestures",id:"version-1.4.6/gestures",title:"Gestures",description:"Due to time constraint, we couldn't complete this page. We will complete as soon as possible.",source:"@site/versioned_docs/version-1.4.6/gestures.md",sourceDirName:".",slug:"/gestures",permalink:"/docs/gestures",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/versioned_docs/version-1.4.6/gestures.md",tags:[],version:"1.4.6",sidebarPosition:5,frontMatter:{sidebar_position:5,id:"gestures",title:"Gestures"},sidebar:"tutorialSidebar",previous:{title:"Animations",permalink:"/docs/animations"},next:{title:"useAnimatedValue",permalink:"/docs/api-references/hooks/use-animated-value"}},c={},p=[{value:"Available gesture hooks",id:"available-gesture-hooks",level:2},{value:"Binding a gesture to a Node",id:"binding-a-gesture-to-a-node",level:2}],d={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Due to time constraint, we couldn't complete this page. We will complete as soon as possible."))),(0,o.kt)("p",null,"Gestures in React UI Animate is a set of gestures that let you bind mouse and touch events to any node. With the data you receive, it becomes easy to set up complex gestures like dragging and scrolling with a few lines of code."),(0,o.kt)("h2",{id:"available-gesture-hooks"},"Available gesture hooks"),(0,o.kt)("p",null,"Currently, the library provides the following list of gesture hooks. All these hooks share similar API pattern:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#"},(0,o.kt)("inlineCode",{parentName:"a"},"useScroll"))," for scroll gesture."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#"},(0,o.kt)("inlineCode",{parentName:"a"},"useMouseMove"))," for mouse move gesture."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#"},(0,o.kt)("inlineCode",{parentName:"a"},"useDrag"))," for drag gesture."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#"},(0,o.kt)("inlineCode",{parentName:"a"},"useWheel"))," for mouse wheel gesture."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#"},(0,o.kt)("inlineCode",{parentName:"a"},"useGesture"))," for multiple gestures.")),(0,o.kt)("h2",{id:"binding-a-gesture-to-a-node"},"Binding a gesture to a Node"),(0,o.kt)("p",null,"Due to similar pattern of gesture hooks, it becomes quite easy to implement any gesture effortlessly. To bind a gesture to a node, the gesture hooks returns a function, which when called returns an object with event handlers. Let say we want a ",(0,o.kt)("inlineCode",{parentName:"p"},"<div />")," to be draggable."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import { useDrag } from 'react-ui-animate';\n\nexport default function () {\n  const bind = useDrag((state) => doSomething(state));\n\n  return (\n    <div\n      {...bind()}\n      style={{\n        width: 60,\n        height: 60,\n        backgroundColor: '#3399ff',\n      }}\n    />\n  );\n}\n")),(0,o.kt)("p",null,"In the above example, a ",(0,o.kt)("inlineCode",{parentName:"p"},"<div />")," receives an object with event handlers when you spread ",(0,o.kt)("inlineCode",{parentName:"p"},"...bind()"),", you're actually adding onPointerDown, onMouseDown, and other event handlers. The ",(0,o.kt)("inlineCode",{parentName:"p"},"useDrag")," hook accepts a callback function with state as a parameter. state is an object containing all attributes of the gesture. The ",(0,o.kt)("inlineCode",{parentName:"p"},"state")," is passed to your handler every time the gesture updates."),(0,o.kt)("p",null,"To actually implement dragging of an element, we should be using it with Animated Value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"import { useDrag, useAnimatedValue, AnimatedBlock } from 'react-ui-animate';\n\nexport default function () {\n  const left = useAnimatedValue(0);\n\n  const bind = useDrag(({ down, movementX }) => {\n    left.value = down ? movementX : 0;\n  });\n\n  return (\n    <AnimatedBlock\n      {...bind()}\n      style={{\n        width: 60,\n        height: 60,\n        backgroundColor: '#3399ff',\n        position: 'absolute',\n        left: left.value,\n      }}\n    />\n  );\n}\n")),(0,o.kt)("p",null,"In the above example, ",(0,o.kt)("inlineCode",{parentName:"p"},"left")," is an animated value. The ",(0,o.kt)("inlineCode",{parentName:"p"},"state")," object has ",(0,o.kt)("inlineCode",{parentName:"p"},"down")," which represents the current state of a mouse click and ",(0,o.kt)("inlineCode",{parentName:"p"},"movementX")," which represents the movement in x-axis always starting from 0."))}m.isMDXComponent=!0}}]);